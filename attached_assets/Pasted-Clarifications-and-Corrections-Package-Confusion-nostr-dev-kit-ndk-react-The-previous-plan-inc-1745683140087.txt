Clarifications and Corrections
Package Confusion (@nostr-dev-kit/ndk-react):
The previous plan incorrectly referenced @nostr-dev-kit/ndk-react, which may not be in your package.json. Based on your feedback, you’re using @nostr-dev-kit/ndk and possibly @nostr-dev-kit/ndk-hooks (a more likely package for React hooks in NDK).

I’ll assume your package.json includes:
json
// client/package.json
{
  "dependencies": {
    "@nostr-dev-kit/ndk": "^2.8.2",
    "@nostr-dev-kit/ndk-hooks": "^1.0.0", // Adjust version if different
    "nostr-tools": "^1.17.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.0.0",
    "ws": "^8.14.2"
  }
}
If @nostr-dev-kit/ndk-hooks isn’t installed, you can install it, or we can use @nostr-dev-kit/ndk directly with minimal changes. For simplicity, I’ll adapt the plan to use @nostr-dev-kit/ndk’s NDK class and useEffect for subscriptions, avoiding the need for ndk-hooks unless you confirm it’s in use.
Incorrect File Reference (FeedFilters.tsx):
The Replit agent attempted to edit FeedFilters.tsx, which isn’t mentioned in your repository or the plan. The plan intended to modify Home.tsx to add the filter selector UI.

I’ll ensure the plan only touches necessary files: useNodusPosts.ts, Home.tsx, App.tsx, and ndk.ts (if relay fixes are needed).
Current Codebase State:
Repository: https://github.com/quirze62/nodus-app-react

Key Files:
useNodusPosts.ts: Fetches kind 1 posts with NIP-05 verification, no filter modes yet.

Home.tsx: Renders the feed using useNodusPosts and PostCard.

App.tsx: Sets up NDKProvider with relays.

ndk.ts: Handles NDK connections.

AuthContext.tsx: Manages user authentication (needed for followers/follows filters).
Assumptions:
The app has a working authentication system (via AuthContext) providing user.pubkey.

Relays are configured but may need reliable ones for Replit (e.g., wss://relay.mynodus.com).

useNodusPosts.ts uses @nostr-dev-kit/ndk (not ndk-hooks) for simplicity, unless you confirm otherwise.
Replit Agent’s Actions:
The agent checked for FilterMode, opened relevant files, but got sidetracked by creating FeedFilters.tsx and referencing ndk-react.

We’ll stop these actions and focus on modifying useNodusPosts.ts and Home.tsx to add filtering, with minimal relay checks in App.tsx.
Short-Term Plan for Replit Agent: Feed Filtering Only
This plan is a simplified, step-by-step guide for your Replit agent to implement filtered feeds (followers, follows, trendy) in the Nodus app’s client directory (nodus-app-react/client). It focuses exclusively on feed filtering, using @nostr-dev-kit/ndk for subscriptions (avoiding ndk-hooks or ndk-react unless you confirm their use). The plan ensures compatibility with Replit’s environment and includes testing in the preview and committing to GitHub.
Timeline: 1-2 days
Goals:
Add filter modes (all, followers, follows, trendy) to useNodusPosts.ts using NDK.

Update Home.tsx with a filter selector UI.

Ensure relays support feed fetching in Replit.

Test filters in the Replit preview.

Commit changes to GitHub.
Step 1: Modify useNodusPosts.ts to Support Filtered Feeds
Objective: Update the useNodusPosts hook to fetch posts based on the selected filter mode.
Tasks:
Open useNodusPosts.ts:
In Replit, navigate to client/src/hooks/useNodusPosts.ts.
Replace the File Content:
Update the hook to add filter modes, fetch follows, and rank trendy posts.
javascript
// client/src/hooks/useNodusPosts.ts
import { useState, useEffect, useContext } from 'react';
import { NDK, NDKEvent } from '@nostr-dev-kit/ndk';
import { DB } from '@/lib/db';
import { AuthContext } from '@/contexts/AuthContext';

interface Post extends NDKEvent {
  id: string;
  pubkey: string;
  content: string;
  created_at: number;
  tags: string[][];
}

type FilterMode = 'all' | 'followers' | 'follows' | 'trendy';

export function useNodusPosts(filterMode: FilterMode = 'all') {
  const { ndk } = useContext(AuthContext);
  const { user } = useContext(AuthContext);
  const [verifiedPosts, setVerifiedPosts] = useState<Post[]>([]);
  const [error, setError] = useState<string | null>(null);
  const db = new DB();

  // Fetch user follows
  const [follows, setFollows] = useState<string[]>([]);
  useEffect(() => {
    if (!ndk || !user) return;
    const fetchFollows = async () => {
      try {
        const followEvent = await ndk.fetchEvent({
          kinds: [3],
          authors: [user.pubkey]
        });
        if (followEvent) {
          const followPubkeys = followEvent.tags
            .filter(tag => tag[0] === 'p')
            .map(tag => tag[1]);
          setFollows(followPubkeys);
          console.log('Follows:', followPubkeys); // Debug
        }
      } catch (err) {
        setError('Failed to fetch follows: ' + err.message);
      }
    };
    fetchFollows();
  }, [ndk, user]);

  // Fetch follows of follows
  const [followsOfFollows, setFollowsOfFollows] = useState<string[]>([]);
  useEffect(() => {
    if (!ndk || !follows.length || filterMode !== 'follows') return;
    const fetchFollowsOfFollows = async () => {
      try {
        const followsEvents = await ndk.fetchEvents({
          kinds: [3],
          authors: follows
        });
        const secondDegreePubkeys = Array.from(followsEvents)
          .flatMap(event => event.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]))
          .filter((pubkey, index, self) => self.indexOf(pubkey) === index);
        setFollowsOfFollows(secondDegreePubkeys);
        console.log('Follows of follows:', secondDegreePubkeys); // Debug
      } catch (err) {
        setError('Failed to fetch follows of follows: ' + err.message);
      }
    };
    fetchFollowsOfFollows();
  }, [ndk, follows, filterMode]);

  // Fetch posts
  const getPostFilter = () => {
    switch (filterMode) {
      case 'followers':
        return { kinds: [1], authors: follows, limit: 50 };
      case 'follows':
        return { kinds: [1], authors: followsOfFollows, limit: 50 };
      case 'trendy':
        return { kinds: [1], limit: 50, since: Math.floor(Date.now() / 1000) - 24 * 3600 };
      default:
        return { kinds: [1], limit: 50 };
    }
  };

  const [postEvents, setPostEvents] = useState<NDKEvent[]>([]);
  useEffect(() => {
    if (!ndk || (filterMode === 'follows' && !followsOfFollows.length)) return;
    const fetchPosts = async () => {
      try {
        const events = await ndk.fetchEvents(getPostFilter());
        setPostEvents(Array.from(events));
      } catch (err) {
        setError('Failed to fetch posts: ' + err.message);
      }
    };
    fetchPosts();
  }, [ndk, filterMode, follows, followsOfFollows]);

  // Fetch engagement for trendy feed
  const [engagementEvents, setEngagementEvents] = useState<NDKEvent[]>([]);
  useEffect(() => {
    if (!ndk || filterMode !== 'trendy') return;
    const fetchEngagement = async () => {
      try {
        const events = await ndk.fetchEvents({
          kinds: [6, 7],
          limit: 1000,
          since: Math.floor(Date.now() / 1000) - 24 * 3600
        });
        setEngagementEvents(Array.from(events));
      } catch (err) {
        setError('Failed to fetch engagement: ' + err.message);
      }
    };
    fetchEngagement();
  }, [ndk, filterMode]);

  // Process posts with NIP-05 verification and trendy ranking
  useEffect(() => {
    const filterPosts = async () => {
      let filteredPosts: Post[] = [];
      for (const event of postEvents) {
        const isVerified = await db.isNip05Verified(event.pubkey, ndk);
        if (isVerified) filteredPosts.push(event as Post);
      }

      if (filterMode === 'trendy') {
        const engagementCounts = engagementEvents.reduce((acc, event) => {
          const postId = event.tags.find(tag => tag[0] === 'e')?.[1];
          if (postId) acc[postId] = (acc[postId] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);

        filteredPosts = filteredPosts
          .map(post => ({
            ...post,
            engagement: engagementCounts[post.id] || 0
          }))
          .sort((a, b) => b.engagement - a.engagement)
          .slice(0, 50);
      }

      setVerifiedPosts(filteredPosts);
      console.log('Filtered posts:', filteredPosts); // Debug
    };
    filterPosts().catch(err => setError('Failed to filter posts: ' + err.message));
  }, [postEvents, engagementEvents, ndk, filterMode]);

  return { posts: verifiedPosts, error };
}

Notes:
Uses @nostr-dev-kit/ndk directly with ndk.fetchEvent and ndk.fetchEvents instead of useSubscribe to avoid dependency on ndk-hooks or ndk-react.

Assumes AuthContext provides ndk and user (with user.pubkey).

Keeps NIP-05 verification via db.ts.

Adds debug logs to track follows, follows of follows, and posts.

Ignores existing createPost, likePost, etc., functions (if present) to focus on filtering.
Testing in Replit:
Run npm start and open the preview.

Check the console (browser DevTools) for logs:
“Follows: [...]” (after login).

“Follows of follows: [...]” (when selecting “follows” filter, added in Step 2).

“Filtered posts: [...]” (when posts load).
Note: Filters won’t be selectable until Home.tsx is updated.
Step 2: Update Home.tsx to Add Filter Selector
Objective: Add a dropdown to switch between filter modes.
Tasks:
Open Home.tsx:
Navigate to client/src/pages/Home.tsx.
Replace the File Content:
Add a <select> dropdown to choose filter modes.
javascript
// client/src/pages/Home.tsx
import { useContext, useState } from 'react';
import { AuthContext } from '@/contexts/AuthContext';
import { useNodusPosts } from '@/hooks/useNodusPosts';
import { PostCard } from '@/components/feed/PostCard';
import { Login } from '@/components/Login';
import { OfflineIndicator } from '@/components/OfflineIndicator';

export const Home = () => {
  const { user, error: authError } = useContext(AuthContext);
  const [filterMode, setFilterMode] = useState<'all' | 'followers' | 'follows' | 'trendy'>('all');
  const { posts, error: postError } = useNodusPosts(filterMode);

  return (
    <div>
      <h1>Nodus Feed</h1>
      <OfflineIndicator />
      {authError && <p style={{ color: 'red' }}>{authError}</p>}
      {postError && <p style={{ color: 'red' }}>{postError}</p>}
      <div>
        <label>Filter: </label>
        <select value={filterMode} onChange={e => setFilterMode(e.target.value as any)}>
          <option value="all">All Posts</option>
          <option value="followers">Followers</option>
          <option value="follows">Follows of Follows</option>
          <option value="trendy">Trendy</option>
        </select>
      </div>
      {!user && <Login />}
      {user && (
        <ul>
          {posts.map(post => (
            <PostCard key={post.id} post={post} />
          ))}
        </ul>
      )}
    </div>
  );
};

Notes:
Assumes existing components (PostCard, Login, OfflineIndicator) are functional.

Displays errors from AuthContext and useNodusPosts for debugging.

Requires a logged-in user for followers/follows filters (via user.pubkey).
Testing in Replit:
Run npm start and open the preview.

Log in using a private key or generate a new keypair (via Login.tsx).

Test each filter mode in the dropdown:
All: Shows all NIP-05 verified kind 1 posts.

Followers: Shows posts from users in your kind 3 contact list (requires follows).

Follows of Follows: Shows posts from second-degree follows.

Trendy: Shows recent posts (past 24 hours) sorted by likes/reposts.
Check the console for:
“Follows: [...]” (non-empty after login).

“Follows of follows: [...]” (non-empty for “follows” filter).

“Filtered posts: [...]” (posts matching the filter).
If no posts appear:
Ensure you’re logged in (followers/follows need user.pubkey).

Check for errors like “Failed to fetch posts” in the UI or console.
Step 3: Ensure Reliable Relays for Feed Fetching
Objective: Verify relays support kind 3, 1, 7, and 6 events in Replit.
Tasks:
Open App.tsx:
Navigate to client/src/App.tsx.
Check and Update Relays:
Ensure reliable relays are used. If not, update:
javascript
// client/src/App.tsx
import { NDK } from '@nostr-dev-kit/ndk';
import { AuthProvider } from '@/contexts/AuthContext';
import { Router } from '@/Router';
import { WebSocket } from 'ws';

global.WebSocket = WebSocket;

const ndk = new NDK({
  explicitRelayUrls: [
    'wss://relay.mynodus.com',
    'wss://relay.damus.io',
    'wss://relay.nostr.info'
  ]
});

export const App = () => (
  <AuthProvider ndk={ndk}>
    <Router />
  </AuthProvider>
);
Notes:
Only update if existing relays are unreliable (e.g., wss://relay.nostr.band).

If your App.tsx uses NDKProvider from ndk-react, let me know, and I’ll adjust the syntax.

These relays support kind 3 (contact lists), kind 1 (posts), kind 7 (likes), and kind 6 (reposts).
Testing in Replit:
Run npm start and open the preview.

Check the console for “NDK connected to relays: [...]” (should include wss://relay.mynodus.com).

If no posts load or filters fail:
Test relay connectivity:
bash
node -e "const WebSocket = require('ws'); const ws = new WebSocket('wss://relay.mynodus.com'); ws.on('open', () => { console.log('Connected'); ws.close(); }); ws.on('error', e => console.error('Error:', e));"
If it fails, try adding wss://relay.nostr.wine to the explicitRelayUrls array and retest.
Step 4: Commit and Test in Replit Preview
Objective: Save changes, test the filtered feeds, and push to GitHub.
Tasks:
Commit Changes:
In Replit’s shell:
bash
cd client
git add .
git commit -m "Add filtered feeds (followers, follows, trendy) in Replit"
git push origin main
Test in Replit Preview:
Run npm start and open the preview.

Log in using a private key or generate a new keypair.

Test each filter mode in the dropdown:
All: Shows all NIP-05 verified kind 1 posts.

Followers: Shows posts from users in your kind 3 contact list (requires follows).

Follows of Follows: Shows posts from second-degree follows.

Trendy: Shows recent posts (past 24 hours) sorted by likes/reposts.
Check the console (browser DevTools) for:
“Follows: [...]” (non-empty after login).

“Follows of follows: [...]” (non-empty for “follows” filter).

“Filtered posts: [...]” (posts matching the filter).
Verify posts load correctly and the UI updates when switching filters.
Debug Issues:
No Posts in Feed:
Ensure you’re logged in (followers/follows require user.pubkey).

Check console for empty follows or followsOfFollows arrays.

Add debug log: console.log('Post events:', postEvents) in useNodusPosts.ts to verify events.
Relays Not Connecting:
Check console for “NDK connected to relays: [...]”.

Test relays individually (see Step 3).
Errors in UI:
Look for “Failed to fetch posts” or similar in the UI/console.

Check for authentication issues: console.log('User:', user) in useNodusPosts.ts.
Testing in Replit:
Confirm all filter modes display relevant posts.

Ensure switching filters updates the feed without errors.

Verify no crashes or blank feeds.
Recommendations for Replit Agent
Focus: Only modify useNodusPosts.ts, Home.tsx, and App.tsx (if needed). Avoid creating new files like FeedFilters.tsx.

NDK Approach: Using ndk.fetchEvent and ndk.fetchEvents is simpler and avoids dependency issues with ndk-hooks or ndk-react.

Debugging:
Add console logs to track data:
javascript
console.log('Filter:', getPostFilter());
console.log('Posts loaded:', verifiedPosts);
Check relay status:
javascript
console.log('Relays:', Array.from(ndk.pool.relays.entries()));
If the followers filter is empty, ensure your Nostr account has a kind 3 event with p tags (follows).
Replit Tips:
If the preview is slow, restart the Replit server: kill 1 in the shell, then npm start.

Monitor console logs in the browser DevTools (F12) for real-time debugging.
Post-Implementation Steps
Verify in Replit:
Test all filter modes in the preview.

Confirm posts load and filters switch correctly.

Check console for debug logs and errors.
Push to GitHub:
Commit and push (Step 4).

This syncs changes for Cursor or other environments.
Debug if Needed:
If filters fail, focus on console logs for follows, followsOfFollows, and postEvents.

If relays are the issue, try adding wss://relay.nostr.wine to App.tsx.
